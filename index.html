<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>二十四节气 - 滑动切换版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'KaiTi', '楷体', serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI 层 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }

        /* 状态指示器 */
        #gesture-status {
            position: absolute; top: 15%;
            font-size: 18px; color: rgba(255,255,255,0.6);
            background: rgba(0,0,0,0.4); padding: 8px 16px; border-radius: 20px;
            letter-spacing: 2px; transition: all 0.2s;
        }
        /* 触发动作时的视觉反馈 */
        #gesture-status.active { 
            color: #fff; background: rgba(46, 139, 87, 0.8); 
            transform: scale(1.1);
        }

        /* 轮盘 */
        #wheel-container {
            width: 320px; height: 320px; 
            border: 2px dashed rgba(255,255,255,0.15); 
            border-radius: 50%; position: absolute;
            display: flex; justify-content: center; align-items: center;
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* 弹性动画 */
        }
        
        #wheel-pointer {
            width: 16px; height: 16px; background: #fff; border-radius: 50%;
            position: absolute; top: -8px; box-shadow: 0 0 15px #fff; z-index: 5;
        }

        /* 节气文字 */
        #term-info { text-align: center; transition: opacity 0.5s; opacity: 0; transform: translateY(20px); }
        #term-info.visible { opacity: 1; transform: translateY(0); }
        #term-title { font-size: 5rem; color: #fff; text-shadow: 0 4px 15px rgba(0,0,0,0.6); margin: 0; }
        #poem-text {
            font-size: 1.6rem; color: rgba(255,255,255,0.95); margin-top: 15px;
            background: rgba(0,0,0,0.3); padding: 10px 30px; border-radius: 50px;
            backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1);
        }

        /* 启动遮罩 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: white; cursor: pointer; pointer-events: auto;
        }
        
        /* 摄像头 (右上角) */
        #webcam { 
            position: absolute; top: 20px; right: 20px; width: 180px; 
            opacity: 0.6; z-index: 3; border-radius: 12px;
            transform: scaleX(-1); /* 镜像翻转：这对坐标判定很重要 */
            border: 2px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>

<div id="overlay">
    <h1 id="status-text">正在初始化引擎...</h1>
    <p id="sub-text">请稍候 (加载 AI 模型中)</p>
</div>

<video id="webcam" autoplay playsinline></video>
<div id="canvas-container"></div>

<div id="ui-layer">
    <div id="gesture-status">伸出食指 · 左右挥动切换</div>
    <div id="term-info" class="visible">
        <h1 id="term-title">惊蛰</h1>
        <div id="poem-text">微雨众卉新，一雷惊蛰始</div>
    </div>
    <div id="wheel-container">
        <div id="wheel-pointer"></div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --- 数据 ---
    const SOLAR_TERMS = [
        { name: "惊蛰", color: 0x2E8B57, poem: "微雨众卉新，一雷惊蛰始", type: "rain", fallbackGeo: "cone" },
        { name: "春分", color: 0xFFB6C1, poem: "春风如贵客，一到便繁华", type: "petals", fallbackGeo: "sphere" },
        { name: "立夏", color: 0xFF7F50, poem: "绿树阴浓夏日长，楼台倒影入池塘", type: "clear", fallbackGeo: "box" },
        { name: "大雪", color: 0xAEC6CF, poem: "柴门闻犬吠，风雪夜归人", type: "snow", fallbackGeo: "sphere" },
        // ... 您可以继续添加更多节气
    ];

    const state = {
        currentTermIndex: 0,
        lastX: null,            // 上一帧食指的 X 坐标
        lastSwitchTime: 0,      // 上次切换的时间 (用于冷却)
        wheelRotation: 0        // 轮盘当前的旋转角度
    };

    // --- Three.js 场景 setup (保持不变) ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.03);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 2, 6);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.8));
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({color:0x111111, roughness:0.8}));
    ground.rotation.x = -Math.PI/2; scene.add(ground);

    // --- 场景与物体更新 ---
    let particleSystem, currentModel;
    const targetBgColor = new THREE.Color(SOLAR_TERMS[0].color);

    function updateScene(term) {
        if(particleSystem) { scene.remove(particleSystem); particleSystem = null; }
        if(term.type !== 'clear') {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<1000; i++) pos.push((Math.random()-0.5)*30, Math.random()*20, (Math.random()-0.5)*30);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color: 0xffffff, size: 0.2, transparent: true, opacity: 0.6});
            particleSystem = new THREE.Points(geo, mat);
            scene.add(particleSystem);
        }
        if(currentModel) scene.remove(currentModel);
        const geo = term.fallbackGeo === 'cone' ? new THREE.ConeGeometry(1,3,32) : new THREE.SphereGeometry(1.5,32,32);
        currentModel = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: term.color, roughness: 0.4}));
        currentModel.position.y = 1.5;
        scene.add(currentModel);
        targetBgColor.setHex(term.color);
    }

    // --- 核心：滑动逻辑更新 ---
    function switchTerm(direction) {
        // direction: 1 (Next/Left Swipe), -1 (Prev/Right Swipe)
        let newIndex = state.currentTermIndex + direction;
        
        // 循环边界处理
        if (newIndex >= SOLAR_TERMS.length) newIndex = 0;
        if (newIndex < 0) newIndex = SOLAR_TERMS.length - 1;

        if (newIndex !== state.currentTermIndex) {
            state.currentTermIndex = newIndex;
            const data = SOLAR_TERMS[newIndex];

            // 1. UI 更新
            const title = document.getElementById('term-title');
            const poem = document.getElementById('poem-text');
            title.style.opacity = 0; poem.style.opacity = 0;
            setTimeout(() => {
                title.innerText = data.name;
                poem.innerText = data.poem;
                title.style.opacity = 1; poem.style.opacity = 1;
                updateScene(data);
            }, 200);

            // 2. 轮盘旋转动画 (每次转 360/24 = 15度，这里演示转 45度)
            state.wheelRotation += direction * 45; 
            document.getElementById('wheel-container').style.transform = `rotate(${state.wheelRotation}deg)`;

            // 3. 状态提示
            const statusUI = document.getElementById('gesture-status');
            statusUI.innerText = direction > 0 ? ">>> 下一个节气" : "<<< 上一个节气";
            statusUI.classList.add('active');
            setTimeout(() => statusUI.classList.remove('active'), 800);
        }
    }

    // --- 视觉识别与手势判定 ---
    let handLandmarker = null;
    async function initVision() {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
            runningMode: "VIDEO", numHands: 1
        });
        const video = document.getElementById("webcam");
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
            video.srcObject = stream;
            video.addEventListener("loadeddata", predict);
        });
    }

    let lastVideoTime = -1;
    function predict() {
        const video = document.getElementById("webcam");
        if (lastVideoTime !== video.currentTime && handLandmarker) {
            lastVideoTime = video.currentTime;
            const results = handLandmarker.detectForVideo(video, performance.now());
            
            if (results.landmarks.length > 0) {
                const lm = results.landmarks[0];
                const indexFingerTip = lm[8]; // 食指指尖
                const currentX = indexFingerTip.x;

                // 当前时间
                const now = Date.now();

                // 只有当距离上次切换超过 500ms 时才检测 (冷却时间)
                if (now - state.lastSwitchTime > 500) {
                    
                    if (state.lastX !== null) {
                        // 计算位移差
                        const deltaX = currentX - state.lastX;
                        
                        // 阈值设定：0.03 (约占屏幕宽度的3%)
                        // 需要一定速度才能触发，防止静止时的微抖动
                        const SWIPE_THRESHOLD = 0.04; 

                        if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
                            // --- 方向判定 (重要) ---
                            // 视频是 scaleX(-1) 镜像的。
                            // MediaPipe 原始数据: 0(左) -> 1(右)
                            // 
                            // 1. 用户向左挥手 (Physically Left)
                            //    镜像画面显示手向右移动 (Visual Right)
                            //    MediaPipe X 值变大 (deltaX > 0)
                            //    动作：切换到"下一个"
                            
                            if (deltaX > 0) {
                                // 实际：向左挥手 -> 下一个
                                switchTerm(1);
                            } else {
                                // 实际：向右挥手 -> 上一个 (切回)
                                switchTerm(-1);
                            }

                            // 记录切换时间，进入冷却
                            state.lastSwitchTime = now;
                        }
                    }
                }
                
                // 更新上一帧位置
                state.lastX = currentX;

            } else {
                // 手消失时重置
                state.lastX = null;
            }
        }
        requestAnimationFrame(predict);
    }

    // --- 动画循环 ---
    function animate() {
        requestAnimationFrame(animate);
        scene.background = scene.background || new THREE.Color();
        scene.background.lerp(targetBgColor, 0.05);
        scene.fog.color.copy(scene.background);
        if (particleSystem) {
            const positions = particleSystem.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) {
                positions[i] -= 0.1;
                if(positions[i] < -10) positions[i] = 10;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
        if(currentModel) currentModel.rotation.y += 0.005; // 待机自转
        renderer.render(scene, camera);
    }

    // --- 启动 ---
    const overlay = document.getElementById('overlay');
    initVision().then(() => {
        document.getElementById('status-text').innerText = "点击开启";
        overlay.addEventListener('click', () => {
            overlay.remove();
            updateScene(SOLAR_TERMS[0]);
            animate();
        });
        overlay.style.cursor = "pointer";
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
