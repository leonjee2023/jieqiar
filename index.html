<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>二十四节气 - 沉浸版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'KaiTi', '楷体', serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI 层 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }

        /* 增强的时间轮盘 */
        #wheel-container {
            width: 300px; height: 300px; 
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%; position: absolute;
            display: flex; justify-content: center; align-items: center;
            transition: border-color 0.3s, box-shadow 0.3s; /* 视觉反馈动画 */
        }
        /* 激活状态（旋转时） */
        #wheel-container.active {
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }
        
        #wheel-pointer {
            width: 12px; height: 12px; background: #fff; border-radius: 50%;
            position: absolute; top: -6px; box-shadow: 0 0 10px #fff;
        }

        /* 节气文字 */
        #term-info { text-align: center; transition: opacity 0.5s; opacity: 0; transform: translateY(20px); }
        #term-info.visible { opacity: 1; transform: translateY(0); }
        #term-title { font-size: 5rem; color: #fff; text-shadow: 0 4px 15px rgba(0,0,0,0.6); margin: 0; }
        #poem-text {
            font-size: 1.6rem; color: rgba(255,255,255,0.95); margin-top: 15px;
            background: rgba(0,0,0,0.3); padding: 10px 30px; border-radius: 50px;
            backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1);
        }

        /* 启动遮罩 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: white; cursor: pointer; pointer-events: auto;
        }
        #overlay h1 { font-size: 24px; margin-bottom: 10px; }
        #overlay p { font-size: 16px; opacity: 0.7; }

        /* 调试摄像头 */
        #webcam { position: absolute; bottom: 0; right: 0; width: 160px; opacity: 0.3; z-index: 3; transform: scaleX(-1); border-radius: 10px; }
    </style>
</head>
<body>

<div id="overlay">
    <h1>点击屏幕开启体验</h1>
    <p>需授权摄像头与音频播放权限</p>
</div>

<video id="webcam" autoplay playsinline></video>
<div id="canvas-container"></div>

<div id="ui-layer">
    <div id="term-info" class="visible">
        <h1 id="term-title">惊蛰</h1>
        <div id="poem-text">微雨众卉新，一雷惊蛰始</div>
    </div>
    <div id="wheel-container">
        <div id="wheel-pointer"></div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --- 配置数据 ---
    // 提示：真实项目中，请将 modelUrl 和 audioUrl 替换为你的本地路径或云端 URL
    const SOLAR_TERMS = [
        { 
            name: "惊蛰", 
            color: 0x2E8B57, 
            poem: "微雨众卉新，一雷惊蛰始", 
            type: "rain", 
            modelUrl: "./models/bamboo_forest.glb", // 示例路径
            audioUrl: "https://actions.google.com/sounds/v1/weather/thunder_rumble.ogg", // 示例：雷声
            fallbackGeo: "cone"
        },
        { 
            name: "春分", 
            color: 0xFFB6C1, 
            poem: "春风如贵客，一到便繁华", 
            type: "petals", 
            modelUrl: "./models/sakura_tree.glb", 
            audioUrl: "https://actions.google.com/sounds/v1/ambiences/forest_morning.ogg", // 示例：鸟语
            fallbackGeo: "sphere"
        },
        { 
            name: "大雪", 
            color: 0xAEC6CF, 
            poem: "柴门闻犬吠，风雪夜归人", 
            type: "snow", 
            modelUrl: "./models/snow_house.glb", 
            audioUrl: "https://actions.google.com/sounds/v1/weather/strong_wind_blowing.ogg", // 示例：风声
            fallbackGeo: "box"
        }
    ];

    // --- 系统状态 ---
    const state = {
        audioEnabled: false,
        currentTermIndex: 0,
        rotationAngle: 0,
        isInteracting: false
    };

    // --- 1. 场景初始化 ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.03);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 2, 6);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // 灯光
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // 地面
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 100),
        new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.2 })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // --- 2. 资源加载管理器 (模型 & 音频) ---
    class ResourceManager {
        constructor(camera) {
            this.gltfLoader = new GLTFLoader();
            this.audioListener = new THREE.AudioListener();
            camera.add(this.audioListener);
            this.sound = new THREE.Audio(this.audioListener);
            this.audioLoader = new THREE.AudioLoader();
            this.currentModel = null;
        }

        // 加载模型 (带 Fallback 机制)
        loadSceneModel(termData) {
            // 移除旧模型
            if (this.currentModel) {
                scene.remove(this.currentModel);
                // 简单的资源清理，实际项目中需要遍历 dispose geometry/material
                this.currentModel = null;
            }

            // 尝试加载 GLTF
            // 注意：如果没有真实模型文件，这里会报错并触发 catch，从而展示 fallback 几何体
            this.gltfLoader.load(
                termData.modelUrl,
                (gltf) => {
                    this.currentModel = gltf.scene;
                    this.currentModel.scale.set(0.5, 0.5, 0.5); // 根据模型大小调整
                    scene.add(this.currentModel);
                },
                undefined, // onProgress
                (error) => {
                    // console.log("模型加载失败，使用备用几何体:", error);
                    this.createFallbackGeometry(termData.fallbackGeo, termData.color);
                }
            );
        }

        createFallbackGeometry(type, color) {
            let geometry;
            if (type === 'cone') geometry = new THREE.ConeGeometry(1, 3, 32);
            else if (type === 'sphere') geometry = new THREE.SphereGeometry(1.5, 32, 32);
            else geometry = new THREE.BoxGeometry(2, 2, 2);

            const material = new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: 0.5,
                emissive: color,
                emissiveIntensity: 0.2
            });
            this.currentModel = new THREE.Mesh(geometry, material);
            this.currentModel.position.y = 1.5;
            scene.add(this.currentModel);
        }

        // 播放环境音 (淡入淡出逻辑)
        playAmbientSound(url) {
            if (!state.audioEnabled) return;

            // 如果正在播放，先淡出
            if (this.sound.isPlaying) {
                const oldSound = this.sound;
                // 创建一个新的 Audio 对象给下一个声音，旧的让他淡出后停止
                // 为了简化 Demo，这里直接硬切，实际可做 GainNode 动画
                oldSound.stop(); 
            }

            this.audioLoader.load(url, (buffer) => {
                this.sound.setBuffer(buffer);
                this.sound.setLoop(true);
                this.sound.setVolume(0.5);
                this.sound.play();
            });
        }
    }

    const resourceManager = new ResourceManager(camera);

    // --- 3. 粒子天气系统 (简化版) ---
    // (保留之前的核心逻辑，增加风的随机性)
    let particleSystem, particleGeo;
    function updateWeather(type) {
        if (particleSystem) { scene.remove(particleSystem); particleSystem = null; }
        if (type === 'clear') return;

        const count = 1500;
        particleGeo = new THREE.BufferGeometry();
        const pos = [], vel = [];
        
        for(let i=0; i<count; i++) {
            pos.push((Math.random()-0.5)*30, Math.random()*20, (Math.random()-0.5)*30);
            vel.push((Math.random()-0.5)*0.2, -Math.random()*0.2 - 0.1, (Math.random()-0.5)*0.2);
        }
        particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        particleGeo.userData = { velocities: vel, type: type };

        // 简单的材质贴图生成
        const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#FFF'; 
        if(type==='rain') ctx.fillRect(14,0,4,32);
        else { ctx.beginPath(); ctx.arc(16,16,10,0,6.28); ctx.fill(); }
        
        const mat = new THREE.PointsMaterial({
            size: type==='rain'?0.4:0.2, 
            map: new THREE.CanvasTexture(canvas), 
            transparent: true, 
            opacity: 0.8, 
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        particleSystem = new THREE.Points(particleGeo, mat);
        scene.add(particleSystem);
    }

    // --- 4. 逻辑控制与反馈 ---
    function switchTerm(index) {
        if (index === state.currentTermIndex) return;
        state.currentTermIndex = index;
        const data = SOLAR_TERMS[index];

        // UI 更新
        const titleEl = document.getElementById('term-title');
        const poemEl = document.getElementById('poem-text');
        const infoBox = document.getElementById('term-info');
        
        // 简单的淡入淡出动画
        infoBox.classList.remove('visible');
        setTimeout(() => {
            titleEl.innerText = data.name;
            poemEl.innerText = data.poem;
            infoBox.classList.add('visible');
        }, 500);

        // 3D 环境更新
        const color = new THREE.Color(data.color);
        // 使用 GSAP 或简单的 lerp 在 animate 中过渡背景色
        targetBgColor.copy(color);

        updateWeather(data.type);
        resourceManager.loadSceneModel(data);
        resourceManager.playAmbientSound(data.audioUrl);
    }

    // --- 5. 手势识别与优化 ---
    let handLandmarker = null;
    let targetRotation = 0; // 目标角度
    let smoothRotation = 0; // 平滑后的角度

    async function initVision() {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
            runningMode: "VIDEO", numHands: 1
        });
        
        const video = document.getElementById("webcam");
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
            video.srcObject = stream;
            video.addEventListener("loadeddata", predict);
        });
    }

    let lastVideoTime = -1;
    function predict() {
        const video = document.getElementById("webcam");
        if (lastVideoTime !== video.currentTime && handLandmarker) {
            lastVideoTime = video.currentTime;
            const results = handLandmarker.detectForVideo(video, performance.now());

            const wheelUI = document.getElementById('wheel-container');

            if (results.landmarks.length > 0) {
                state.isInteracting = true;
                wheelUI.classList.add('active'); // 激活 UI 发光反馈

                const lm = results.landmarks[0];
                const p1 = lm[4], p2 = lm[8]; // 拇指与食指
                
                // 计算原始角度
                let rawAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                
                // --- 优化点：角度防抖 ---
                // 只有当变化量超过一定阈值时才更新目标，防止手指静止时的微颤
                if (Math.abs(rawAngle - targetRotation) > 0.05) {
                    targetRotation = rawAngle;
                }

                // 映射节气
                // 将 -PI~PI 映射到 0~1，再分段
                let normalized = (smoothRotation + Math.PI) / (2 * Math.PI); 
                // 防止边界跳变 (从 0.99 跳到 0.01 的情况需特殊处理，这里简化处理)
                if (normalized < 0) normalized += 1;
                
                const termIndex = Math.floor(normalized * SOLAR_TERMS.length) % SOLAR_TERMS.length;
                switchTerm(termIndex);

            } else {
                state.isInteracting = false;
                wheelUI.classList.remove('active');
            }
        }
        requestAnimationFrame(predict);
    }

    // --- 6. 动画循环 ---
    const targetBgColor = new THREE.Color(SOLAR_TERMS[0].color);

    function animate() {
        requestAnimationFrame(animate);

        // 平滑旋转数值 (Lerp)
        smoothRotation = THREE.MathUtils.lerp(smoothRotation, targetRotation, 0.1);
        
        // 更新 UI 轮盘旋转
        const deg = smoothRotation * (180 / Math.PI);
        document.getElementById('wheel-container').style.transform = `rotate(${deg}deg)`;

        // 背景色渐变
        scene.background = scene.background || new THREE.Color();
        scene.background.lerp(targetBgColor, 0.05);
        scene.fog.color.copy(scene.background);

        // 粒子动画
        if (particleSystem) {
            const positions = particleGeo.attributes.position.array;
            const vels = particleGeo.userData.velocities;
            for(let i=0; i<positions.length/3; i++) {
                positions[i*3+1] += vels[i*3+1]; // Y轴下落
                // 简单的循环
                if(positions[i*3+1] < 0) positions[i*3+1] = 20;
            }
            particleGeo.attributes.position.needsUpdate = true;
            // 雪花/雨随交互微旋转
            particleSystem.rotation.y = smoothRotation * 0.5;
        }

        // 模型自转
        if (resourceManager.currentModel) {
            resourceManager.currentModel.rotation.y += 0.005;
        }

        renderer.render(scene, camera);
    }

    // --- 启动流程 ---
    document.getElementById('overlay').addEventListener('click', function() {
        this.style.opacity = 0;
        setTimeout(() => this.remove(), 500);
        state.audioEnabled = true;
        
        // 初始化第一个场景
        targetBgColor.setHex(SOLAR_TERMS[0].color);
        resourceManager.loadSceneModel(SOLAR_TERMS[0]);
        updateWeather(SOLAR_TERMS[0].type);
        resourceManager.playAmbientSound(SOLAR_TERMS[0].audioUrl);
        
        initVision();
        animate();
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
