<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二十四节气 - 单向滑动版</title>
    <style>
        /* --- 基础样式 --- */
        body { margin: 0; overflow: hidden; background: #000; font-family: 'KaiTi', '楷体', serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* --- UI 层布局 --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }

        /* 状态提示胶囊 */
        #gesture-status {
            position: absolute; top: 15%;
            font-size: 16px; color: rgba(255,255,255,0.7);
            background: rgba(0,0,0,0.4); padding: 8px 20px; border-radius: 30px;
            letter-spacing: 1.5px; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255,255,255,0.1);
        }
        /* 激活时的视觉反馈 */
        #gesture-status.active { 
            color: #fff; background: rgba(46, 139, 87, 0.9); 
            transform: scale(1.1); border-color: rgba(255,255,255,0.5);
        }

        /* 时间轮盘 */
        #wheel-container {
            width: 340px; height: 340px; 
            border: 1px dashed rgba(255,255,255,0.2); 
            border-radius: 50%; position: absolute;
            display: flex; justify-content: center; align-items: center;
            transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1);
        }
        #wheel-inner {
            width: 300px; height: 300px; border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.05);
            position: absolute;
        }
        #wheel-pointer {
            width: 12px; height: 12px; background: #fff; border-radius: 50%;
            position: absolute; top: -6px; box-shadow: 0 0 15px #fff; z-index: 5;
        }

        /* 节气文字与诗词 */
        #term-info { text-align: center; transition: opacity 0.6s ease; opacity: 0; transform: translateY(20px); }
        #term-info.visible { opacity: 1; transform: translateY(0); }
        #term-title { font-size: 5rem; color: #fff; text-shadow: 0 5px 20px rgba(0,0,0,0.5); margin: 0; letter-spacing: 5px; }
        #poem-text {
            font-size: 1.5rem; color: rgba(255,255,255,0.9); margin-top: 20px;
            background: rgba(255,255,255,0.1); padding: 12px 35px; border-radius: 50px;
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        /* 启动遮罩 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 100;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: white; cursor: pointer; pointer-events: auto; transition: opacity 0.5s;
        }
        
        /* 摄像头 (右上角) */
        #webcam { 
            position: absolute; top: 20px; right: 20px; width: 160px; 
            opacity: 0.5; z-index: 3; border-radius: 12px;
            transform: scaleX(-1); /* 镜像翻转 */
            border: 1px solid rgba(255,255,255,0.2);
            transition: opacity 0.3s;
        }
        #webcam:hover { opacity: 1; }
    </style>
</head>
<body>

<div id="overlay">
    <h1 id="status-text">系统初始化中...</h1>
    <p id="sub-text">正在加载 AI 视觉模型</p>
</div>

<video id="webcam" autoplay playsinline></video>
<div id="canvas-container"></div>

<div id="ui-layer">
    <div id="gesture-status">伸出食指 · 向左挥动切换</div>
    
    <div id="term-info" class="visible">
        <h1 id="term-title">立春</h1>
        <div id="poem-text">阳和起蛰，品物皆春</div>
    </div>
    
    <div id="wheel-container">
        <div id="wheel-inner"></div>
        <div id="wheel-pointer"></div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --- 1. 24节气数据 ---
    const SOLAR_TERMS = [
        // 春 (Spring)
        { name: "立春", color: 0x98FB98, poem: "阳和起蛰，品物皆春", type: "petals", fallbackGeo: "cone" },
        { name: "雨水", color: 0x87CEFA, poem: "随风潜入夜，润物细无声", type: "rain", fallbackGeo: "sphere" },
        { name: "惊蛰", color: 0x2E8B57, poem: "微雨众卉新，一雷惊蛰始", type: "rain", fallbackGeo: "cone" },
        { name: "春分", color: 0xFFB6C1, poem: "春风如贵客，一到便繁华", type: "petals", fallbackGeo: "sphere" },
        { name: "清明", color: 0xADD8E6, poem: "清明时节雨纷纷，路上行人欲断魂", type: "rain", fallbackGeo: "box" },
        { name: "谷雨", color: 0x32CD32, poem: "杨花落尽子规啼，闻道龙标过五溪", type: "rain", fallbackGeo: "cone" },
        // 夏 (Summer)
        { name: "立夏", color: 0xFF7F50, poem: "绿树阴浓夏日长，楼台倒影入池塘", type: "clear", fallbackGeo: "box" },
        { name: "小满", color: 0xFFA500, poem: "夜莺啼绿柳，皓月醒长空", type: "clear", fallbackGeo: "sphere" },
        { name: "芒种", color: 0xFFD700, poem: "家家麦饭美，处处菱歌长", type: "clear", fallbackGeo: "cone" },
        { name: "夏至", color: 0xFF4500, poem: "东边日出西边雨，道是无晴却有晴", type: "rain", fallbackGeo: "sphere" },
        { name: "小暑", color: 0xFF8C00, poem: "荷风送香气，竹露滴清响", type: "clear", fallbackGeo: "box" },
        { name: "大暑", color: 0xB22222, poem: "赤日几时过，清风无处寻", type: "clear", fallbackGeo: "cone" },
        // 秋 (Autumn)
        { name: "立秋", color: 0xDAA520, poem: "空山新雨后，天气晚来秋", type: "clear", fallbackGeo: "box" },
        { name: "处暑", color: 0xCD853F, poem: "离离原上草，一岁一枯荣", type: "clear", fallbackGeo: "sphere" },
        { name: "白露", color: 0xF0E68C, poem: "露从今夜白，月是故乡明", type: "clear", fallbackGeo: "cone" },
        { name: "秋分", color: 0xD2691E, poem: "自古逢秋悲寂寥，我言秋日胜春朝", type: "petals", fallbackGeo: "sphere" },
        { name: "寒露", color: 0xA0522D, poem: "萧疏桐叶上，月白露初团", type: "clear", fallbackGeo: "box" },
        { name: "霜降", color: 0x708090, poem: "停车坐爱枫林晚，霜叶红于二月花", type: "petals", fallbackGeo: "cone" },
        // 冬 (Winter)
        { name: "立冬", color: 0x778899, poem: "北风往复几寒凉，疏木摇空半绿黄", type: "clear", fallbackGeo: "box" },
        { name: "小雪", color: 0xB0C4DE, poem: "晚来天欲雪，能饮一杯无", type: "snow", fallbackGeo: "sphere" },
        { name: "大雪", color: 0xE0FFFF, poem: "柴门闻犬吠，风雪夜归人", type: "snow", fallbackGeo: "cone" },
        { name: "冬至", color: 0xF0F8FF, poem: "天时人事日相催，冬至阳生春又来", type: "snow", fallbackGeo: "sphere" },
        { name: "小寒", color: 0xF5F5F5, poem: "小寒连大吕，欢鹊垒新巢", type: "snow", fallbackGeo: "box" },
        { name: "大寒", color: 0xFFFAFA, poem: "旧雪未及消，新雪又拥户", type: "snow", fallbackGeo: "cone" }
    ];

    // --- 2. 状态管理 ---
    const state = {
        currentTermIndex: 0,
        lastX: null,            
        lastSwitchTime: 0,      
        wheelRotation: 0
    };

    // --- 3. Three.js 场景 ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.03);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 2, 7);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 }));
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // --- 4. 场景元素 ---
    let particleSystem = null;
    let currentModel = null;
    const targetBgColor = new THREE.Color(SOLAR_TERMS[0].color);

    function updateScene(term) {
        if (particleSystem) { scene.remove(particleSystem); particleSystem.geometry.dispose(); particleSystem = null; }

        if (term.type !== 'clear') {
            const count = 1500;
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for (let i = 0; i < count; i++) {
                pos.push((Math.random() - 0.5) * 40, Math.random() * 20, (Math.random() - 0.5) * 30);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));

            let pColor = 0xffffff;
            if (term.type === 'petals') {
                const autumnTerms = ["立秋", "处暑", "白露", "秋分", "寒露", "霜降"];
                if (autumnTerms.includes(term.name)) pColor = 0xFFD700; else pColor = 0xFFB6C1;
            }

            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFF';
            if (term.type === 'rain') ctx.fillRect(14, 0, 4, 32);
            else { ctx.beginPath(); ctx.arc(16, 16, 10, 0, Math.PI * 2); ctx.fill(); }
            
            const mat = new THREE.PointsMaterial({
                color: pColor, size: term.type === 'rain' ? 0.3 : 0.2, map: new THREE.CanvasTexture(canvas),
                transparent: true, opacity: 0.7, depthWrite: false, blending: THREE.AdditiveBlending
            });
            particleSystem = new THREE.Points(geo, mat);
            particleSystem.userData = { type: term.type };
            scene.add(particleSystem);
        }

        if (currentModel) scene.remove(currentModel);
        let geometry;
        if (term.fallbackGeo === 'cone') geometry = new THREE.ConeGeometry(1, 3, 6);
        else if (term.fallbackGeo === 'sphere') geometry = new THREE.IcosahedronGeometry(1.5, 0);
        else geometry = new THREE.BoxGeometry(2, 2, 2);

        const material = new THREE.MeshStandardMaterial({ color: term.color, roughness: 0.3, emissive: term.color, emissiveIntensity: 0.1 });
        currentModel = new THREE.Mesh(geometry, material);
        currentModel.position.y = 1.5;
        scene.add(currentModel);

        targetBgColor.setHex(term.color);
    }

    // --- 5. 切换逻辑 ---
    function switchTerm(direction) {
        let newIndex = state.currentTermIndex + direction;
        if (newIndex >= SOLAR_TERMS.length) newIndex = 0;
        if (newIndex < 0) newIndex = SOLAR_TERMS.length - 1;

        if (newIndex !== state.currentTermIndex) {
            state.currentTermIndex = newIndex;
            const data = SOLAR_TERMS[newIndex];

            const title = document.getElementById('term-title');
            const poem = document.getElementById('poem-text');
            const infoBox = document.getElementById('term-info');
            const statusUI = document.getElementById('gesture-status');
            
            infoBox.classList.remove('visible');
            setTimeout(() => {
                title.innerText = data.name;
                poem.innerText = data.poem;
                infoBox.classList.add('visible');
                updateScene(data);
            }, 400);

            state.wheelRotation += direction * 15; 
            document.getElementById('wheel-container').style.transform = `rotate(${state.wheelRotation}deg)`;

            statusUI.innerText = ">>> 进入下一节气";
            statusUI.classList.add('active');
            setTimeout(() => {
                statusUI.classList.remove('active');
                statusUI.innerText = "伸出食指 · 向左挥动切换";
            }, 1000);
        }
    }

    // --- 6. 视觉识别 ---
    let handLandmarker = null;
    async function initVision() {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
            runningMode: "VIDEO", numHands: 1
        });
        const video = document.getElementById("webcam");
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        video.addEventListener("loadeddata", predictLoop);
    }

    let lastVideoTime = -1;
    function predictLoop() {
        const video = document.getElementById("webcam");
        if (lastVideoTime !== video.currentTime && handLandmarker) {
            lastVideoTime = video.currentTime;
            const results = handLandmarker.detectForVideo(video, performance.now());
            
            if (results.landmarks.length > 0) {
                const lm = results.landmarks[0];
                const indexTip = lm[8];
                const currentX = indexTip.x;
                const now = Date.now();

                // 冷却时间
                if (now - state.lastSwitchTime > 500) {
                    if (state.lastX !== null) {
                        const deltaX = currentX - state.lastX;
                        // 阈值检测
                        if (Math.abs(deltaX) > 0.04) {
                            // --- 修改点：仅识别向左滑动 ---
                            // 由于镜像翻转，deltaX > 0 意味着视觉上向左移动
                            if (deltaX > 0) {
                                switchTerm(1); // 只有这里触发
                                state.lastSwitchTime = now; // 触发后重置冷却
                            }
                            // deltaX < 0 的情况（向右滑动）被忽略
                        }
                    }
                    state.lastX = currentX;
                }
            } else {
                state.lastX = null;
            }
        }
        requestAnimationFrame(predictLoop);
    }

    // --- 7. 动画 ---
    function animate() {
        requestAnimationFrame(animate);
        scene.background = scene.background || new THREE.Color();
        scene.background.lerp(targetBgColor, 0.03);
        scene.fog.color.copy(scene.background);

        if (particleSystem) {
            const positions = particleSystem.geometry.attributes.position.array;
            const type = particleSystem.userData.type;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] -= (type === 'rain' ? 0.4 : 0.1); 
                if (positions[i] < -10) positions[i] = 20;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.rotation.y += 0.002;
        }
        if (currentModel) {
            currentModel.rotation.y += 0.005;
            currentModel.rotation.x = Math.sin(Date.now() * 0.001) * 0.1;
        }
        renderer.render(scene, camera);
    }

    // --- 8. 启动 ---
    const overlay = document.getElementById('overlay');
    initVision().then(() => {
        document.getElementById('status-text').innerText = "点击屏幕开启体验";
        document.getElementById('sub-text').innerText = "交互已就绪 · 单向滑动控制";
        overlay.addEventListener('click', () => {
            overlay.style.opacity = 0;
            setTimeout(() => overlay.remove(), 500);
            updateScene(SOLAR_TERMS[0]);
            animate();
        });
        overlay.style.cursor = "pointer";
    });
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
