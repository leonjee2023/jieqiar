<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>二十四节气 - 交互优化版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'KaiTi', '楷体', serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI 层 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }

        /* 状态指示器 (辅助用户了解当前是否捏合成功) */
        #gesture-status {
            position: absolute; top: 20%;
            font-size: 14px; color: rgba(255,255,255,0.5);
            letter-spacing: 2px; transition: color 0.3s;
        }
        #gesture-status.active { color: #00FF7F; font-weight: bold; text-shadow: 0 0 10px #00FF7F; }

        /* 增强的时间轮盘 */
        #wheel-container {
            width: 320px; height: 320px; 
            border: 2px dashed rgba(255,255,255,0.15); /* 虚线更有刻度感 */
            border-radius: 50%; position: absolute;
            display: flex; justify-content: center; align-items: center;
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.1s; /* 移除 transform 的缓动，改用 JS 控制 */
        }
        /* 激活状态 */
        #wheel-container.active {
            border: 2px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.02);
        }
        
        #wheel-pointer {
            width: 16px; height: 16px; background: #fff; border-radius: 50%;
            position: absolute; top: -8px; box-shadow: 0 0 15px #fff;
            z-index: 5;
        }

        /* 节气文字 */
        #term-info { text-align: center; transition: opacity 0.5s; opacity: 0; transform: translateY(20px); }
        #term-info.visible { opacity: 1; transform: translateY(0); }
        #term-title { font-size: 5rem; color: #fff; text-shadow: 0 4px 15px rgba(0,0,0,0.6); margin: 0; }
        #poem-text {
            font-size: 1.6rem; color: rgba(255,255,255,0.95); margin-top: 15px;
            background: rgba(0,0,0,0.3); padding: 10px 30px; border-radius: 50px;
            backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1);
        }

        /* 启动遮罩 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: white; cursor: pointer; pointer-events: auto;
        }
        
        /* --- 优化 1: 摄像头置于右上角 --- */
        #webcam { 
            position: absolute; 
            top: 20px;       /* 顶部 */
            right: 20px;     /* 右侧 */
            width: 180px; 
            opacity: 0.6;    /* 稍微提高不透明度以便观察手势 */
            z-index: 3; 
            transform: scaleX(-1); /* 镜像翻转 */
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>

<div id="overlay">
    <h1 id="status-text">正在初始化引擎...</h1>
    <p id="sub-text">请稍候 (加载 AI 模型中)</p>
</div>

<video id="webcam" autoplay playsinline></video>
<div id="canvas-container"></div>

<div id="ui-layer">
    <div id="gesture-status">请捏合手指以旋转</div>
    <div id="term-info" class="visible">
        <h1 id="term-title">惊蛰</h1>
        <div id="poem-text">微雨众卉新，一雷惊蛰始</div>
    </div>
    <div id="wheel-container">
        <div id="wheel-pointer"></div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --- 配置数据 ---
    const SOLAR_TERMS = [
        { name: "惊蛰", color: 0x2E8B57, poem: "微雨众卉新，一雷惊蛰始", type: "rain", fallbackGeo: "cone" },
        { name: "春分", color: 0xFFB6C1, poem: "春风如贵客，一到便繁华", type: "petals", fallbackGeo: "sphere" },
        { name: "立夏", color: 0xFF7F50, poem: "绿树阴浓夏日长，楼台倒影入池塘", type: "clear", fallbackGeo: "box" },
        { name: "大雪", color: 0xAEC6CF, poem: "柴门闻犬吠，风雪夜归人", type: "snow", fallbackGeo: "sphere" }
    ];

    const state = {
        currentTermIndex: 0,
        isPinching: false,  // 是否处于捏合状态
        wheelAngle: 0,      // 轮盘当前的实际角度 (累积)
        lastHandAngle: null // 上一帧手的角度
    };

    // --- Three.js 基础场景 (保持不变) ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.03);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 2, 6);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.8));
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({color:0x111111, roughness:0.8}));
    ground.rotation.x = -Math.PI/2; scene.add(ground);

    // --- 简单的粒子与模型逻辑 (简化版用于演示) ---
    let particleSystem;
    let currentModel;
    function updateScene(term) {
        // 1. 粒子
        if(particleSystem) { scene.remove(particleSystem); particleSystem = null; }
        if(term.type !== 'clear') {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<1000; i++) pos.push((Math.random()-0.5)*30, Math.random()*20, (Math.random()-0.5)*30);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color: 0xffffff, size: 0.2, transparent: true, opacity: 0.6});
            particleSystem = new THREE.Points(geo, mat);
            scene.add(particleSystem);
        }
        // 2. 模型
        if(currentModel) scene.remove(currentModel);
        const geo = term.fallbackGeo === 'cone' ? new THREE.ConeGeometry(1,3,32) : new THREE.SphereGeometry(1.5,32,32);
        currentModel = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: term.color, roughness: 0.4}));
        currentModel.position.y = 1.5;
        scene.add(currentModel);
        
        // 3. 背景
        targetBgColor.setHex(term.color);
    }
    const targetBgColor = new THREE.Color(SOLAR_TERMS[0].color);

    // --- UI 更新逻辑 ---
    function updateUI(index) {
        if(index === state.currentTermIndex) return;
        state.currentTermIndex = index;
        const data = SOLAR_TERMS[index];
        
        // 只有当数据改变时才刷新 DOM
        const title = document.getElementById('term-title');
        const poem = document.getElementById('poem-text');
        
        // 简单的淡入淡出
        title.style.opacity = 0; poem.style.opacity = 0;
        setTimeout(() => {
            title.innerText = data.name;
            poem.innerText = data.poem;
            title.style.opacity = 1; poem.style.opacity = 1;
            updateScene(data);
        }, 200);
    }

    // --- 核心：手势识别与控制优化 ---
    let handLandmarker = null;

    async function initVision() {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
            runningMode: "VIDEO", numHands: 1
        });
        const video = document.getElementById("webcam");
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
            video.srcObject = stream;
            video.addEventListener("loadeddata", predict);
        });
    }

    // 计算两点距离
    function getDistance(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    // 计算最短旋转路径 (解决 359度 -> 1度 的反转问题)
    function shortestAngleDist(a, b) {
        let diff = b - a;
        while (diff > Math.PI) diff -= 2 * Math.PI;
        while (diff < -Math.PI) diff += 2 * Math.PI;
        return diff;
    }

    let lastVideoTime = -1;
    function predict() {
        const video = document.getElementById("webcam");
        if (lastVideoTime !== video.currentTime && handLandmarker) {
            lastVideoTime = video.currentTime;
            const results = handLandmarker.detectForVideo(video, performance.now());
            
            const wheelUI = document.getElementById('wheel-container');
            const statusUI = document.getElementById('gesture-status');

            if (results.landmarks.length > 0) {
                const lm = results.landmarks[0];
                const thumb = lm[4];
                const index = lm[8];
                
                // 1. 判断是否捏合 (离合器逻辑)
                // 距离阈值通常在 0.05 - 0.1 之间，根据实际调试设定
                const pinchDist = getDistance(thumb, index);
                const isPinching = pinchDist < 0.08; 

                if (isPinching) {
                    // --- 捏合状态：控制旋转 ---
                    state.isPinching = true;
                    wheelUI.classList.add('active');
                    statusUI.innerText = "已吸附 - 转动控制";
                    statusUI.classList.add('active');

                    // 计算当前手的角度
                    const currentHandAngle = Math.atan2(thumb.y - index.y, thumb.x - index.x);

                    if (state.lastHandAngle !== null) {
                        // 计算角度差 (Delta)，并累加到轮盘角度
                        // 使用 shortestAngleDist 防止从 -PI 跳到 PI 时的剧烈抖动
                        const delta = shortestAngleDist(state.lastHandAngle, currentHandAngle);
                        
                        // 灵敏度系数 (1.5倍数意味着手转90度，轮盘转135度，减少手腕负担)
                        const sensitivity = 1.5;
                        state.wheelAngle += delta * sensitivity;
                    }
                    
                    state.lastHandAngle = currentHandAngle;

                } else {
                    // --- 松开状态：停止控制 ---
                    state.isPinching = false;
                    state.lastHandAngle = null; // 重置上一帧角度
                    wheelUI.classList.remove('active');
                    statusUI.innerText = "请捏合手指以旋转";
                    statusUI.classList.remove('active');
                }

            } else {
                state.isPinching = false;
                state.lastHandAngle = null;
                wheelUI.classList.remove('active');
            }

            // --- 2. 视觉同步与节气映射 ---
            // 规范化角度到 0 - 1 之间 (0 = 0度, 1 = 360度)
            // 将累积的角度取模，保证一直在圆圈内
            let normalizedRotation = (state.wheelAngle % (Math.PI * 2)) / (Math.PI * 2);
            if (normalizedRotation < 0) normalizedRotation += 1; // 处理负数

            // 映射到数组索引
            const totalTerms = SOLAR_TERMS.length;
            const termIndex = Math.floor(normalizedRotation * totalTerms);
            updateUI(termIndex);

            // 更新 UI 轮盘的 CSS 旋转
            // 直接使用 state.wheelAngle 可以保证多圈旋转时不回弹
            const deg = state.wheelAngle * (180 / Math.PI);
            wheelUI.style.transform = `rotate(${deg}deg)`;
        }
        requestAnimationFrame(predict);
    }

    // --- 动画循环 ---
    function animate() {
        requestAnimationFrame(animate);
        // 背景颜色平滑过渡
        scene.background = scene.background || new THREE.Color();
        scene.background.lerp(targetBgColor, 0.05);
        scene.fog.color.copy(scene.background);
        
        // 粒子下落动画
        if (particleSystem) {
            const positions = particleSystem.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) {
                positions[i] -= 0.1;
                if(positions[i] < -10) positions[i] = 10;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
        renderer.render(scene, camera);
    }

    // --- 启动逻辑 ---
    const overlay = document.getElementById('overlay');
    const statusText = document.getElementById('status-text');
    
    initVision().then(() => {
        statusText.innerText = "点击屏幕开启体验";
        overlay.addEventListener('click', () => {
            overlay.style.display = 'none';
            // 初始化首个场景
            updateScene(SOLAR_TERMS[0]);
            animate();
        });
        overlay.style.cursor = "pointer";
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
